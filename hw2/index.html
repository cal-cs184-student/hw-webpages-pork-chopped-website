<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
			<div style="text-align: center;">Names: Karson Du, Patrick Sanchez </div>

			<br>

			Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-pork-chopped-website/hw2/index.html">Webpage</a>

			<br>

			Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw-webpages-pork-chopped-website">Repo</a>

			<figure>
				<img src="teapot.png" alt="Teapot" style="width:50%" />
				<figcaption>They Tea on my Pot till I upsample</figcaption>
			</figure>

			<!--
	We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
	-->

			<h2>Overview</h2>
			Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

			<h2>Section I: Bezier Curves and Surfaces</h2>

			<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
			de Casteljaus algorithm is basically just using lerps on the edges between control points, since we have n - 1 edges, each level of the algorithm gives us one less point, we connect the edges on a parameter t that indicates how far along the edge we lerp on. We essentially lerp until we are left with one point, this point acts as our tracer for our bezier curve, as we change t from 0 to 1, we use our tracer point to draw out the bezier curve along all possible values of t.
			How we implemented it was by first implementing 1 step of de Casteljau's algorithm which is just a single lerp stage using the formula (1-t)P<sub>i</sub> + t p<sub>i+1</sub>. we do the on the first n-1 control points so that on our last call we don't get an out of bounds error, doing this step gives us new n-1 control points, so by repeating this this until we end up with only a singular point, we can get a tracer point that draws the bezier curve along the values of all t.

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="Bezier1.PNG" width="400px" />
							<figcaption>Step 1.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="bezier2.PNG" width="400px" />
							<figcaption>Step 2.</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="bezier3.PNG" width="400px" />
							<figcaption>Step 3.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="bezier4.PNG" width="400px" />
							<figcaption>Step 4.</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="bezier5.PNG" width="400px" />
							<figcaption>Step 5.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="bezier6.PNG" width="400px" />
							<figcaption>Final Step.</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="otherbezier.PNG" width="400px" />
							<figcaption>Slightly Different Bezier curve with different value of t.</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
			Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
			de Casteljau algorithm extends to Bezier surfaces by first making bezier curves along one direction first such as along the x axis first and by doing it on some parameter u, we get 1 control point per bezier curve which results in n control point, 1 from each of the n bezier curves, we then run de Casteljau algorithm on these n points with a second parameter v in order to give us a bezier surface.
			The way we implemented this was by first iterating through each of the n rows which had m control points each and running de Casteljau algorithm on these m points along the parameter u to end up with n curves and n points, and then using our second parameter v, we make a new bezier curve with the n points as control points and v as the parameter to describe a point on the Bezier surface.
			<figure>
				<img src="task2.PNG" alt="Teapot" style="width:50%" />
				<figcaption>bez/teapot.bez</figcaption>
			</figure>

			<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

			<h3>Part 3: Area-weighted vertex normals</h3>
			How we implemented the area-weighted vertex normals was by starting from our half edge, and then while moving to every other half edge, we grabbed the locations of the three vertices that make up the triangle that the current half edge belongs to, with these vertices, we could do subtraction to end up with vectors for the base and height of the triangles, we also grabbed the normal vector of each face since it is a member variable of the halfedge's face. Using the cross product and normalization, we calculate the area of the triangle and since we already have the normal vector we just multiply the area by this normal vector to weight the area by the normal, by doing this for all halfedges we get a sum of weighted areas. All we have to do afterwards is return the normalized sum to get the approximate unit normal.

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="task3pre.PNG" width="400px" />
							<figcaption>Default Flat Shading.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="task3post.PNG" width="400px" />
							<figcaption>Phong Shading.</figcaption>
						</td>
					</tr>
				</table>
			</div>


			<h3>Part 4: Edge flip</h3>
<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
>>>>>>> 19be6134f4f08943c4b25888ce8050aa8c0afbd1
			To implement the edge flip operation, we first saved everything our current state which included all the half edges, all the vertices, all the edges, and all the faces. Then using the setNeighbors method we changed all the member variables of each half edge, so according to a drawing of the two triangles we made, we set the next, twin, vertex, edge, and face for every halfedge that we saved. Afterwards we set all the halfedge pointers in the faces, edges, and vertices we saved to a working and valid halfedge accoridng to our drawing, we then just simply return the original edge we were given which is now properly flipped.

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="Task4 unflipped.png" width="400px" />
							<figcaption>Default unflipped teapot.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="Task4 One Flip.png" width="400px" />
							<figcaption>One diagonal flipped.</figcaption>
						</td>
						
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="Task4 Several Flip.png" width="400px" />
							<figcaption>Several diagnolas flipped.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="EdgeFlip.jpg" width="400px" />
							<figcaption>Diagram of EdgeFlip algorithm.</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h3>Part 5: Edge split</h3>

			Our edge split algorithm builds upon the same process as edge flips, except we not only reassign but also add new pointers (for the new faces, vertices, and edges). In particular, splitting the median line turns it into a cross of four edges (but only three are new because the original middle line can be reassigned to be one of the four edges of the cross). We followed the same naming scheme for the outer halfedges, and added six new inner half edges, three new inner edges, two new inner faces, and one new midpoint vertex.

			After drawing a new diagram for edge split, we decided to turn the middle line into the upper middle line after the middle edge is split. From there, the three new edges (and their six halfedges) go left, right, and down from the new mid point (which is weighted between the top and bottom original vertices). The original two faces are designated to the top two faces, and the two new faces are assigned to the bottom faces of the cross. Minimizing the changes from the edge split code made it easier to double-check our pointer assignments!

			Debugging edge split was not as bad as edge flip after we understood the general workflow. The biggest hiccup came when we were calculating the mid point position, as we were trying to average between all four outer vertices, when we only had to consider vertices B and C. Small errors in setting the mesh neighbors also arose due to rushing the diagram reading, which caused the splits to sometimes delete entire faces.

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="Task5 Unsplit.png" width="400px" />
							<figcaption>Default unsplit teapot mesh.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="Task5 Vertical Split and Flip.png" width="400px" />
							<figcaption>Edges flipped along one vertical line, and split on the other side.</figcaption>
						</td>
						
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="Task5 Several Split and Flip.png" width="400px" />
							<figcaption>Combination of edge flips and splits on the same edges.</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="EdgeSplit.jpg" width="400px" />
							<figcaption>Diagram of EdgeSplit algorithm.</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h3>Part 6: Loop subdivision for mesh upsampling</h3>
			Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

			<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
			Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		</div>
</body>
</html>